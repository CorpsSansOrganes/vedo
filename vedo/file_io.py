import glob
import os
import time
from tempfile import NamedTemporaryFile, TemporaryDirectory

import numpy as np

import vedo.vtkclasses as vtk

import vedo
from vedo import settings
from vedo import colors
from vedo import utils
from vedo.assembly import Assembly
from vedo.image import Image
from vedo.pointcloud import Points
from vedo.mesh import Mesh
from vedo.volume import Volume

__docformat__ = "google"

__doc__ = """
Submodule to read/write meshes and other objects in different formats,
and other I/O functionalities.
"""

__all__ = [
    "load",
    "download",
    "gunzip",
    "loadStructuredPoints",
    "loadStructuredGrid",
    "loadRectilinearGrid",
    # "load_transform", # LinearTransform("file.mat") substitutes this
    "write",
    "export_window",
    "import_window",
    "screenshot",
    "ask",
    "Video",
]


# example web page for X3D
_x3d_html_template = """
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title> vedo with x3d </title>

  <!-- THESE ARE THE RELEVANT LINES: -->
  <script src='https://www.x3dom.org/download/x3dom.js'> </script>
  <link rel='stylesheet' type='text/css' href='https://www.x3dom.org/download/x3dom.css'/>

  <style>
     table, td, th { border: 1px solid black; background-color: powderblue;}
     table {width: 70%; border-collapse: collapse;}
     table th {width: 35%;}
  </style>
</head>

<body style="font-family: Verdana">
  <h1>Example html generated by vedo</h1>
  This example loads a 3D scene from file ~fileoutput generated by
  <a href="https://github.com/marcomusy/vedo">vedo</a>
  (see <a href="https://github.com/marcomusy/vedo/tree/master/examples/other/export_x3d.py">export_x3d.py</a>).
  <br><br>


  <!-- THESE ARE THE RELEVANT LINES: -->
  <x3d width='~widthpx' height='~heightpx'>
     <scene>
        <Inline url="~fileoutput"> </Inline>
     </scene>
  </x3d>

  <h3>Nothing shows up above this line?</h3>
  Enable your browser to load local files:
  <br><b>Firefox</b>: type <code>about:config</code> in the URL bar and
  change <code>privacy.file_unique_origin</code> from <code>True</code> to <code>False</code>
  <br><b>Chrome</b>: from terminal type:
  <code>google-chrome --enable-webgl --allow-file-access-from-files</code>
  (see <a href="https://cmatskas.com/interacting-with-local-data-files-using-chrome/">here</a>)

  <br>
  <h3>Controls:</h3>
  <h4><strong>Examine Mode (activate with key 'e'):</strong></h4>
  <table>
     <tbody>
        <tr class="even description">
           <th>Button</th>
           <th>Function</th>
        </tr>
        <tr>
           <td>Left Button / Left Button + Shift</td>
           <td>Rotate</td>
        </tr>
        <tr>
           <td>Mid Button / Left Button + Ctl</td>
           <td>Pan</td>
        </tr>
        <tr>
           <td>Right Button / Wheel / Left Button + Alt</td>
           <td>Zoom</td>
        </tr>
        <tr>
           <td>Left double click</td>
           <td>Set center of rotation</td>
        </tr>
     </tbody>
  </table>
  <h4><strong>Walk Mode (activate with key 'w'):</strong></h4>
  <table>
     <tbody>
        <tr class="even description">
           <th>Button</th>
           <th>Function</th>
        </tr>
        <tr>
           <td>Left Button</td>
           <td>Move forward</td>
        </tr>
        <tr>
           <td>Right Button</td>
           <td>Move backward</td>
        </tr>
     </tbody>
  </table>
  <h4><strong>Fly Mode (activate with key 'f'):</strong></h4>
  <table>
     <tbody>
        <tr class="even description">
           <th>Button</th>
           <th>Function</th>
        </tr>
        <tr>
           <td>Left Button</td>
           <td>Move forward</td>
        </tr>
        <tr>
           <td>Right Button</td>
           <td>Move backward</td>
        </tr>
     </tbody>
  </table>
  <h3>Non-interactive camera movement</h3>
  <table>
     <tbody>
        <tr class="even description">
           <th>Key</th>
           <th>Function</th>
        </tr>
        <tr>
           <td>r</td>
           <td>reset view</td>
        </tr>
        <tr>
           <td>a</td>
           <td>show all</td>
        </tr>
        <tr>
           <td>u</td>
           <td>upright</td>
        </tr>
     </tbody>
  </table>
</body>
</html>
"""

########################################################################
def load(inputobj, unpack=True, force=False):
    """
    Load any vedo objects from file or from the web.

    The output will depend on the file extension. See examples below.
    Unzip is made on the fly, if file ends with `.gz`.
    Can load an object directly from a URL address.

    Arguments:
        unpack : bool
            unpack MultiBlockData into a flat list of objects.

        force : bool
            when downloading a file ignore any previous cached downloads and force a new one.

    Example:
        ```python
        from vedo import dataurl, load, show
        # Return a list of 2 meshes
        g = load([dataurl+'250.vtk', dataurl+'270.vtk'])
        show(g)
        # Return a list of meshes by reading all files in a directory
        # (if directory contains DICOM files then a Volume is returned)
        g = load('mydicomdir/')
        show(g)
        ```
    """
    acts = []
    if utils.is_sequence(inputobj):
        flist = inputobj
    elif isinstance(inputobj, str) and inputobj.startswith("https://"):
        flist = [inputobj]
    else:
        # flist = sorted(glob.glob(inputobj))
        flist = utils.humansort(glob.glob(inputobj))

    for fod in flist:

        if fod.startswith("https://"):
            fod = download(fod, force=force, verbose=False)

        if os.path.isfile(fod):  ### it's a file

            if fod.endswith(".gz"):
                fod = gunzip(fod)

            a = _load_file(fod, unpack)
            acts.append(a)

        elif os.path.isdir(fod):  ### it's a directory or DICOM
            flist = os.listdir(fod)
            if ".dcm" in flist[0]:  ### it's DICOM
                reader = vtk.new("DICOMImageReader")
                reader.SetDirectoryName(fod)
                reader.Update()
                image = reader.GetOutput()
                vol = Volume(image)
                vol.info["PixelSpacing"] = reader.GetPixelSpacing()
                vol.info["Width"] = reader.GetWidth()
                vol.info["Height"] = reader.GetHeight()
                vol.info["PositionPatient"] = reader.GetImagePositionPatient()
                vol.info["OrientationPatient"] = reader.GetImageOrientationPatient()
                vol.info["BitsAllocated"] = reader.GetBitsAllocated()
                vol.info["PixelRepresentation"] = reader.GetPixelRepresentation()
                vol.info["NumberOfComponents"] = reader.GetNumberOfComponents()
                vol.info["TransferSyntaxUID"] = reader.GetTransferSyntaxUID()
                vol.info["RescaleSlope"] = reader.GetRescaleSlope()
                vol.info["RescaleOffset"] = reader.GetRescaleOffset()
                vol.info["PatientName"] = reader.GetPatientName()
                vol.info["StudyUID"] = reader.GetStudyUID()
                vol.info["StudyID"] = reader.GetStudyID()
                vol.info["GantryAngle"] = reader.GetGantryAngle()
                acts.append(vol)

            else:  ### it's a normal directory
                utils.humansort(flist)
                for ifile in flist:
                    a = _load_file(fod + "/" + ifile, unpack)
                    acts.append(a)
        else:
            vedo.logger.error(f"in load(), cannot find {fod}")

    if len(acts) == 1:
        if "numpy" in str(type(acts[0])):
            return acts[0]
        if not acts[0]:
            vedo.logger.error(f"in load(), cannot load {inputobj}")
        return acts[0]

    if len(acts) == 0:
        vedo.logger.error(f"in load(), cannot load {inputobj}")
        return None

    else:
        return acts

########################################################################
def _load_file(filename, unpack):
    fl = filename.lower()

    ########################################################## other formats:
    if fl.endswith(".xml") or fl.endswith(".xml.gz") or fl.endswith(".xdmf"):
        # Fenics tetrahedral file
        actor = loadDolfin(filename)
    elif fl.endswith(".neutral") or fl.endswith(".neu"):  # neutral tets
        actor = loadNeutral(filename)
    elif fl.endswith(".gmsh"):  # gmesh file
        actor = loadGmesh(filename)
    elif fl.endswith(".pcd"):  # PCL point-cloud format
        actor = loadPCD(filename)
        actor.GetProperty().SetPointSize(2)
    elif fl.endswith(".off"):
        actor = loadOFF(filename)
    elif fl.endswith(".3ds"):  # 3ds format
        actor = load3DS(filename)
    elif fl.endswith(".wrl"):
        importer = vtk.new("VRMLImporter")
        importer.SetFileName(filename)
        importer.Read()
        importer.Update()
        actors = importer.GetRenderer().GetActors()  # vtkActorCollection
        actors.InitTraversal()
        wacts = []
        for i in range(actors.GetNumberOfItems()):
            act = actors.GetNextActor()
            wacts.append(act)
        actor = Assembly(wacts)

    ######################################################## volumetric:
    elif (
        fl.endswith(".tif")
        or fl.endswith(".tiff")
        or fl.endswith(".slc")
        or fl.endswith(".vti")
        or fl.endswith(".mhd")
        or fl.endswith(".nrrd")
        or fl.endswith(".nii")
        or fl.endswith(".dem")
    ):
        img = loadImageData(filename)
        actor = Volume(img)

    ######################################################### 2D images:
    elif (
        fl.endswith(".png")
        or fl.endswith(".jpg")
        or fl.endswith(".bmp")
        or fl.endswith(".jpeg")
        or fl.endswith(".gif")
    ):
        if ".png" in fl:
            picr = vtk.new("PNGReader")
        elif ".jpg" in fl or ".jpeg" in fl:
            picr = vtk.new("JPEGReader")
        elif ".bmp" in fl:
            picr = vtk.new("BMPReader")
        elif ".gif" in fl:
            from PIL import Image as PILImage, ImageSequence

            img = PILImage.open(filename)
            frames = []
            for frame in ImageSequence.Iterator(img):
                a = np.array(frame.convert("RGB").getdata(), dtype=np.uint8)
                a = a.reshape([frame.size[1], frame.size[0], 3])
                frames.append(Image(a))
            return frames

        picr.SetFileName(filename)
        picr.Update()
        actor = Image(picr.GetOutput())

    ######################################################### multiblock:
    elif fl.endswith(".vtm") or fl.endswith(".vtmb"):
        read = vtk.new("XMLMultiBlockDataReader")
        read.SetFileName(filename)
        read.Update()
        mb = read.GetOutput()
        if unpack:
            acts = []
            for i in range(mb.GetNumberOfBlocks()):
                b = mb.GetBlock(i)
                if isinstance(
                    b,
                    (
                        vtk.vtkPolyData,
                        vtk.vtkStructuredGrid,
                        vtk.vtkRectilinearGrid,
                    ),
                ):
                    acts.append(Mesh(b))
                elif isinstance(b, vtk.vtkImageData):
                    acts.append(Volume(b))
                elif isinstance(b, vtk.vtkUnstructuredGrid):
                    acts.append(vedo.UGrid(b))
            return acts
        return mb

    ###########################################################
    elif fl.endswith(".geojson"):
        return loadGeoJSON(filename)

    elif fl.endswith(".pvd"):
        return loadPVD(filename)

    ########################################################### polygonal mesh:
    else:
        if fl.endswith(".vtk"):  # read all legacy vtk types
            reader = vtk.new("DataSetReader")
            reader.ReadAllScalarsOn()
            reader.ReadAllVectorsOn()
            reader.ReadAllTensorsOn()
            reader.ReadAllFieldsOn()
            reader.ReadAllNormalsOn()
            reader.ReadAllColorScalarsOn()
        elif fl.endswith(".ply"):
            reader = vtk.new("PLYReader")
        elif fl.endswith(".obj"):
            reader = vtk.new("OBJReader")
        elif fl.endswith(".stl"):
            reader = vtk.new("STLReader")
        elif fl.endswith(".byu") or fl.endswith(".g"):
            reader = vtk.new("BYUReader")
        elif fl.endswith(".foam"):  # OpenFoam
            reader = vtk.new("OpenFOAMReader")
        elif fl.endswith(".pvd"):
            reader = vtk.new("XMLGenericDataObjectReader")
        elif fl.endswith(".vtp"):
            reader = vtk.new("XMLPolyDataReader")
        elif fl.endswith(".vts"):
            reader = vtk.new("XMLStructuredGridReader")
        elif fl.endswith(".vtu"):
            reader = vtk.new("XMLUnstructuredGridReader")
        elif fl.endswith(".vtr"):
            reader = vtk.new("XMLRectilinearGridReader")
        elif fl.endswith(".pvtr"):
            reader = vtk.new("XMLPRectilinearGridReader")
        elif fl.endswith("pvtu"):
            reader = vtk.new("XMLPUnstructuredGridReader")
        elif fl.endswith(".txt") or fl.endswith(".xyz"):
            reader = vtk.new("ParticleReader")  # (format is x, y, z, scalar)
        elif fl.endswith(".facet"):
            reader = vtk.new("FacetReader")
        else:
            return None

        reader.SetFileName(filename)
        reader.Update()
        routput = reader.GetOutput()

        if not routput:
            vedo.logger.error(f"unable to load {filename}") 
            return None

        if isinstance(routput, vtk.vtkUnstructuredGrid):
            actor = vedo.TetMesh(routput)

        else:
            actor = Mesh(routput)
            if fl.endswith(".txt") or fl.endswith(".xyz"):
                actor.point_size(4)

    actor.filename = filename
    actor.file_size, actor.created = file_info(filename)
    return actor

########################################################################
def download(url, force=False, verbose=True):
    """
    Retrieve a file from a URL, save it locally and return its path.
    Use `force=True` to force a reload and discard cached copies.
    """
    if not url.startswith("https://"):
        # vedo.logger.error(f"Invalid URL (must start with https):\n{url}")
        # assume it's a file so no need to download
        return url
    url = url.replace("www.dropbox", "dl.dropbox")

    if "github.com" in url:
        url = url.replace("/blob/", "/raw/")

    basename = os.path.basename(url)

    if "?" in basename:
        basename = basename.split("?")[0]

    tmp_file = NamedTemporaryFile(delete=False)
    tmp_file.name = os.path.join(os.path.dirname(tmp_file.name), os.path.basename(basename))

    if not force and os.path.exists(tmp_file.name):
        if verbose:
            colors.printc("reusing cached file:", tmp_file.name)
            # colors.printc("     (use force=True to force a new download)")
        return tmp_file.name

    try:
        from urllib.request import urlopen, Request
        req = Request(url, headers={"User-Agent": "Mozilla/5.0"})
        if verbose:
            colors.printc("reading", basename, "from", url.split("/")[2][:40], "...", end="")

    except ImportError:
        import urllib2
        import contextlib
        urlopen = lambda url_: contextlib.closing(urllib2.urlopen(url_))
        req = url
        if verbose:
            colors.printc("reading", basename, "from", url.split("/")[2][:40], "...", end="")

    with urlopen(req) as response, open(tmp_file.name, "wb") as output:
        output.write(response.read())

    if verbose:
        colors.printc(" done.")
    return tmp_file.name

########################################################################
def gunzip(filename):
    """Unzip a `.gz` file to a temporary file and returns its path."""
    if not filename.endswith(".gz"):
        # colors.printc("gunzip() error: file must end with .gz", c='r')
        return filename
    import gzip

    tmp_file = NamedTemporaryFile(delete=False)
    tmp_file.name = os.path.join(
        os.path.dirname(tmp_file.name), os.path.basename(filename).replace(".gz", "")
    )
    inF = gzip.open(filename, "rb")
    with open(tmp_file.name, "wb") as outF:
        outF.write(inF.read())
    inF.close()
    return tmp_file.name

########################################################################
def file_info(file_path):
    """Return the file size and creation time of input file"""
    siz, created = "", ""
    if os.path.isfile(file_path):
        f_info = os.stat(file_path)
        num = f_info.st_size
        for x in ["B", "KB", "MB", "GB", "TB"]:
            if num < 1024.0:
                break
            num /= 1024.0
        siz = "%3.1f%s" % (num, x)
        created = time.ctime(os.path.getmtime(file_path))
    return siz, created


###################################################################
def loadStructuredPoints(filename, as_points=True):
    """
    Load and return a `vtkStructuredPoints` object from file.
    
    If `as_points` is True, return a `Points` object
    instead of a `vtkStructuredPoints`.
    """
    reader = vtk.new("StructuredPointsReader")
    reader.SetFileName(filename)
    reader.Update()
    if as_points:
        v2p = vtk.new("ImageToPoints")
        v2p.SetInputData(reader.GetOutput())
        v2p.Update()
        pts = Points(v2p.GetOutput())
        return pts
    return reader.GetOutput()

########################################################################
def loadStructuredGrid(filename):
    """Load and return a `vtkStructuredGrid` object from file."""
    if filename.endswith(".vts"):
        reader = vtk.new("XMLStructuredGridReader")
    else:
        reader = vtk.new("StructuredGridReader")
    reader.SetFileName(filename)
    reader.Update()
    return reader.GetOutput()

def loadRectilinearGrid(filename):
    """Load and return a `vtkRectilinearGrid` object from file."""
    if filename.endswith(".vtr"):
        reader = vtk.new("XMLRectilinearGridReader")
    else:
        reader = vtk.new("RectilinearGridReader")
    reader.SetFileName(filename)
    reader.Update()
    return reader.GetOutput()

########################################################################
def loadXMLData(filename):
    """Read any type of vtk data object encoded in XML format."""
    reader = vtk.new("XMLGenericDataObjectReader")
    reader.SetFileName(filename)
    reader.Update()
    return reader.GetOutput()


###################################################################
def load3DS(filename):
    """Load `3DS` file format from file."""
    renderer = vtk.vtkRenderer()
    renWin = vtk.vtkRenderWindow()
    renWin.AddRenderer(renderer)

    importer = vtk.new("3DSImporter")
    importer.SetFileName(filename)
    importer.ComputeNormalsOn()
    importer.SetRenderWindow(renWin)
    importer.Update()

    actors = renderer.GetActors()  # vtkActorCollection
    acts = []
    for i in range(actors.GetNumberOfItems()):
        a = actors.GetItemAsObject(i)
        acts.append(a)
    del renWin

    wrapped_acts = []
    for a in acts:
        try:
            newa = Mesh(a.GetMapper().GetInput())
            newa.apply_transform(a.GetMatrix())
            newa.copy_properties_from(a)
            wrapped_acts.append(newa)
        except:
            print("ERROR: cannot load 3DS object", [a])
    return wrapped_acts

########################################################################
def loadOFF(filename):
    """Read the OFF file format (polygonal mesh)."""
    with open(filename, "r", encoding="UTF-8") as f:
        lines = f.readlines()

    vertices = []
    faces = []
    NumberOfVertices = None
    i = -1
    for text in lines:
        if len(text) == 0:
            continue
        if text == "\n":
            continue
        if "#" in text:
            continue
        if "OFF" in text:
            continue

        ts = text.split()
        n = len(ts)

        if not NumberOfVertices and n > 1:
            NumberOfVertices, NumberOfFaces = int(ts[0]), int(ts[1])
            continue
        i += 1

        if i < NumberOfVertices and n == 3:
            x, y, z = float(ts[0]), float(ts[1]), float(ts[2])
            vertices.append([x, y, z])

        ids = []
        if NumberOfVertices <= i < (NumberOfVertices + NumberOfFaces + 1) and n > 2:
            ids += [int(xx) for xx in ts[1:]]
            faces.append(ids)

    return Mesh(utils.buildPolyData(vertices, faces))

########################################################################
def loadGeoJSON(filename):
    """Load GeoJSON files."""
    jr = vtk.new("GeoJSONReader")
    jr.SetFileName(filename)
    jr.Update()
    return Mesh(jr.GetOutput())

########################################################################
def loadDolfin(filename, exterior=False):
    """Reads a `Fenics/Dolfin` file format (.xml or .xdmf).
    Return an `Mesh` object."""
    import dolfin

    if filename.lower().endswith(".xdmf"):
        f = dolfin.XDMFFile(filename)
        m = dolfin.Mesh()
        f.read(m)
    else:
        m = dolfin.Mesh(filename)

    bm = dolfin.BoundaryMesh(m, "exterior")

    if exterior:
        poly = utils.buildPolyData(bm.coordinates(), bm.cells(), tetras=True)
    else:
        polyb = utils.buildPolyData(bm.coordinates(), bm.cells(), tetras=True)
        polym = utils.buildPolyData(m.coordinates(), m.cells(), tetras=True)
        app = vtk.new("AppendPolyData")
        app.AddInputData(polym)
        app.AddInputData(polyb)
        app.Update()
        poly = app.GetOutput()
    return Mesh(poly).lw(1)

########################################################################
def loadPVD(filename):
    """Read paraview files."""
    import xml.etree.ElementTree as et

    tree = et.parse(filename)

    dname = os.path.dirname(filename)
    if not dname:
        dname = "."

    listofobjs = []
    for coll in tree.getroot():
        for dataset in coll:
            fname = dataset.get("file")
            ob = load(dname + "/" + fname)
            tm = dataset.get("timestep")
            if tm:
                ob.time = tm
            listofobjs.append(ob)
    if len(listofobjs) == 1:
        return listofobjs[0]
    if len(listofobjs) == 0:
        return None
    return listofobjs

########################################################################
def loadNeutral(filename):
    """
    Reads a `Neutral` tetrahedral file format.
    Returns an `Mesh` object.
    """
    with open(filename, "r", encoding="UTF-8") as f:
        lines = f.readlines()

    ncoords = int(lines[0])
    coords = []
    for i in range(1, ncoords + 1):
        x, y, z = lines[i].split()
        coords.append([float(x), float(y), float(z)])

    ntets = int(lines[ncoords + 1])
    idolf_tets = []
    for i in range(ncoords + 2, ncoords + ntets + 2):
        text = lines[i].split()
        v0, v1, v2, v3 = int(text[1]) - 1, int(text[2]) - 1, int(text[3]) - 1, int(text[4]) - 1
        idolf_tets.append([v0, v1, v2, v3])

    poly = utils.buildPolyData(coords, idolf_tets)
    return Mesh(poly)

########################################################################
def loadGmesh(filename):
    """Reads a `gmesh` file format. Return an `Mesh` object."""
    with open(filename, "r", encoding="UTF-8") as f:
        lines = f.readlines()

    nnodes = 0
    index_nodes = 0
    for i, line in enumerate(lines):
        if "$Nodes" in line:
            index_nodes = i + 1
            nnodes = int(lines[index_nodes])
            break
    node_coords = []
    for i in range(index_nodes + 1, index_nodes + 1 + nnodes):
        cn = lines[i].split()
        node_coords.append([float(cn[1]), float(cn[2]), float(cn[3])])

    nelements = 0
    index_elements = 0
    for i, line in enumerate(lines):
        if "$Elements" in line:
            index_elements = i + 1
            nelements = int(lines[index_elements])
            break
    elements = []
    for i in range(index_elements + 1, index_elements + 1 + nelements):
        ele = lines[i].split()
        elements.append([int(ele[-3]), int(ele[-2]), int(ele[-1])])

    poly = utils.buildPolyData(node_coords, elements, indexOffset=1)
    return Mesh(poly)

########################################################################
def loadPCD(filename):
    """Return a `Mesh` made of only vertex points
    from the `PointCloud` library file format.
    
    Returns an `Points` object.
    """
    with open(filename, "r", encoding="UTF-8") as f:
        lines = f.readlines()

    start = False
    pts = []
    N, expN = 0, 0
    for text in lines:
        if start:
            if N >= expN:
                break
            l = text.split()
            pts.append([float(l[0]), float(l[1]), float(l[2])])
            N += 1
        if not start and "POINTS" in text:
            expN = int(text.split()[1])
        if not start and "DATA ascii" in text:
            start = True
    if expN != N:
        vedo.logger.warning(f"Mismatch in PCD file {expN} != {len(pts)}")
    poly = utils.buildPolyData(pts)
    return Points(poly).point_size(4)

#########################################################################
def _import_npy(fileinput):
    """Import a vedo scene from numpy format."""
    # make sure the numpy file is not containing a scene
    fileinput = download(fileinput, verbose=False, force=True)
    if fileinput.endswith(".npy"):
        data = np.load(fileinput, allow_pickle=True, encoding="latin1").flatten()[0]
    elif fileinput.endswith(".npz"):
        data = np.load(fileinput, allow_pickle=True)["vedo_scenes"][0]

    if "render_lines_as_tubes" in data.keys():
        settings.render_lines_as_tubes = data["render_lines_as_tubes"]
    if "hidden_line_removal" in data.keys():
        settings.hidden_line_removal = data["hidden_line_removal"]
    if "use_parallel_projection" in data.keys():
        settings.use_parallel_projection = data["use_parallel_projection"]
    if "use_polygon_offset" in data.keys():
        settings.use_polygon_offset = data["use_polygon_offset"]
    if "polygon_offset_factor" in data.keys():
        settings.polygon_offset_factor = data["polygon_offset_factor"]
    if "polygon_offset_units" in data.keys():
        settings.polygon_offset_units = data["polygon_offset_units"]
    if "interpolate_scalars_before_mapping" in data.keys():
        settings.interpolate_scalars_before_mapping = data["interpolate_scalars_before_mapping"]
    if "default_font" in data.keys():
        settings.default_font = data["default_font"]
    if "use_depth_peeling" in data.keys():
        settings.use_depth_peeling = data["use_depth_peeling"]

    axes = data.pop("axes", 4)
    title = data.pop("title", "")
    backgrcol = data.pop("backgrcol", "white")
    backgrcol2 = data.pop("backgrcol2", None)
    cam = data.pop("camera", None)

    if data["shape"] != (1, 1):
        data["size"] = "auto"  # disable size

    plt = vedo.Plotter(
        size=data["size"],  # not necessarily a good idea to set it
        axes=axes,
        title=title,
        bg=backgrcol,
        bg2=backgrcol2,
    )

    if cam:
        if "pos" in cam.keys():
            plt.camera.SetPosition(cam["pos"])
        if "focalPoint" in cam.keys():
            plt.camera.SetFocalPoint(cam["focalPoint"])
        if "focal_point" in cam.keys():
            plt.camera.SetFocalPoint(cam["focal_point"])
        if "viewup" in cam.keys():
            plt.camera.SetViewUp(cam["viewup"])
        if "distance" in cam.keys():
            plt.camera.SetDistance(cam["distance"])
        if "clippingRange" in cam.keys():
            plt.camera.SetClippingRange(cam["clippingRange"])
        if "clipping_range" in cam.keys():
            plt.camera.SetClippingRange(cam["clipping_range"])
        if "parallel_scale" in cam.keys():
            plt.camera.SetParallelScale(cam["parallel_scale"])
        plt.resetcam = False

    ##########################
    def _load_common(obj, d):
        keys = d.keys()
        if "time" in keys: obj.time = d["time"]
        if "name" in keys: obj.name = d["name"]
        if "info" in keys: obj.info = d["info"]
        if "filename" in keys: obj.filename = d["filename"]

    ###########################
    def _buildmesh(d):
        keys = d.keys()

        vertices = d["points"]
        if len(vertices) == 0:
            return None
        cells = d["cells"] if "cells" in keys else None
        lines = d["lines"] if "lines" in keys else None

        msh = Mesh([vertices, cells, lines])
        _load_common(msh, d)

        prp = msh.properties
        if 'ambient' in keys:        prp.SetAmbient(d['ambient'])
        if 'diffuse' in keys:        prp.SetDiffuse(d['diffuse'])
        if 'specular' in keys:       prp.SetSpecular(d['specular'])
        if 'specularpower' in keys:  prp.SetSpecularPower(d['specularpower'])
        if 'specularcolor' in keys:  prp.SetSpecularColor(d['specularcolor'])
        if 'lighting_is_on' in keys: prp.SetLighting(d['lighting_is_on'])
        if 'shading' in keys:        prp.SetInterpolation(d['shading'])
        if 'alpha' in keys:          prp.SetOpacity(d['alpha'])
        if 'representation' in keys: prp.SetRepresentation(d['representation'])
        if 'pointsize' in keys and d['pointsize']: prp.SetPointSize(d['pointsize'])
        if 'linewidth' in keys and d['linewidth']: msh.linewidth(d['linewidth'])
        if 'linecolor' in keys and d['linecolor']: msh.linecolor(d['linecolor'])
        if 'color' in keys and d['color'] is not None:
            msh.color(d['color'])
        if 'backcolor' in keys and d['backcolor'] is not None:
            msh.backcolor(d['backcolor'])

        # print("XXXXX n",
        #     msh.dataset.GetNumberOfPoints(),
        #     msh.dataset.GetNumberOfCells(),
        #     msh.dataset.GetNumberOfLines(),
        #     msh.dataset.GetNumberOfPolys(),
        #     msh.dataset.GetNumberOfStrips(),
        #     msh.dataset.GetNumberOfVerts(),
        # )

        if "celldata" in keys and isinstance(d["celldata"], dict):
            for arrname, arr in d["celldata"].items():
                msh.celldata[arrname] = arr
        if "pointdata" in keys and isinstance(d["pointdata"], dict):
            for arrname, arr in d["pointdata"].items():
                msh.pointdata[arrname] = arr

        # print(msh)


        msh.mapper.ScalarVisibilityOff()
        if "LUT" in keys and "activedata" in keys and d["activedata"]:
            lut_list = d["LUT"]
            ncols = len(lut_list)
            lut = vtk.vtkLookupTable()
            lut.SetNumberOfTableValues(ncols)
            lut.SetRange(d["LUT_range"])
            for i in range(ncols):
                r, g, b, a = lut_list[i]
                lut.SetTableValue(i, r, g, b, a)
            lut.Build()
            msh.mapper.SetLookupTable(lut)
            msh.mapper.ScalarVisibilityOn()  # activate scalars
            msh.mapper.SetScalarRange(d["LUT_range"])
            if d["activedata"][0] == "celldata":
                msh.dataset.GetCellData().SetActiveScalars(d["activedata"][1])
                # msh.celldata.select(d["activedata"][1])
            if d["activedata"][0] == "pointdata":
                msh.dataset.GetPointData().SetActiveScalars(d["activedata"][1])
                # msh.pointdata.select(d["activedata"][1])

        # print("shading", int(d["shading"]),d["scalarvisibility"], d["activedata"][1])
        if "shading" in keys and int(d["shading"]) > 0:
            msh.compute_normals(cells=0)  # otherwise cannot renderer phong
            
        if "scalarvisibility" in keys:
            if d["scalarvisibility"]:
                msh.mapper.ScalarVisibilityOn()
            else:
                msh.mapper.ScalarVisibilityOff()

        return msh

    ##############################################
    objs = []
    for d in data["objects"]:
        ### Mesh
        if d['type'].lower() == 'mesh':
            a = _buildmesh(d)
            if a:
                objs.append(a)

        ### Assembly
        elif d['type'].lower() == 'assembly':
            assacts = []
            for ad in d["actors"]:
                assacts.append(_buildmesh(ad))
            asse = Assembly(assacts)
            _load_common(asse, d)
            objs.append(asse)

        ### Volume
        elif d['type'].lower() == 'volume':
            vol = Volume(d["array"])
            _load_common(vol, d)
            if "jittering" in d.keys(): vol.jittering(d["jittering"])
            vol.mode(d["mode"])
            vol.color(d["color"])
            vol.alpha(d["alpha"])
            vol.alpha_gradient(d["alphagrad"])
            objs.append(vol)

        ### Image
        elif d['type'].lower() == 'picture' or d['type'].lower() == 'image':
            vimg = Image(d["array"])
            _load_common(vimg, d)
            objs.append(vimg)

        ### Text2D
        elif d['type'].lower() == 'text2d':
            t = vedo.shapes.Text2D(d["text"], font=d["font"], c=d["color"])
            t.pos(d["position"]).size(d["size"])
            t.background(d["bgcol"], d["alpha"])
            if d["frame"]:
                t.frame(d["bgcol"])
            objs.append(t)

        ### Annotation     ## backward compatibility - will disappear
        elif d['type'].lower() == 'annotation':
            pos = d["position"]
            if isinstance(pos, int):
                pos = "top-left"
                d["size"] *= 2.7
            t = vedo.shapes.Text2D(d["text"], font=d["font"], c=d["color"]).pos(pos)
            t.background(d["bgcol"], d["alpha"]).size(d["size"]).frame(d["bgcol"])
            objs.append(t)  ## backward compatibility - will disappear

    plt.add(objs)
    return plt

###########################################################
def _import_hdf5(fileinput):
    try:
        import h5py
    except ImportError as e:
        vedo.logger.error(f"{e}. Try: 'pip install h5py'")
        return
    hfile = h5py.File(fileinput, "r")

    scene = hfile["scene"]

    settings.use_depth_peeling = scene["use_depth_peeling"][()]
    settings.render_lines_as_tubes = scene["render_lines_as_tubes"][()]
    settings.hidden_line_removal = scene["hidden_line_removal"][()]
    settings.use_parallel_projection = scene["use_parallel_projection"][()]
    settings.default_font = scene["default_font"][()].decode("utf-8")

    plt = vedo.Plotter(
        pos=scene["position"][()], 
        size=scene["size"][()],
        axes=scene["axes"][()],
        title=scene["title"][()].decode("utf-8"), 
        bg=scene["background_color"][()],
        bg2=scene["background_color2"][()],
    )
    
    objects = scene["objects"]

    for name, hob in objects.items():

        if hob["type"][()].decode("utf-8") == 'Mesh':
            # print(name, hob, hob["type"][()])

            dataset = hob["dataset"]
            props = hob["properties"]

            vertices = dataset["points"][()]
            cells = dataset["cells"][()]
            lines = dataset["lines"][()]

            msh = Mesh([vertices, cells, lines])
            msh.name = hob["name"][()].decode("utf-8")
            # msh.info = hob["info"]
            msh.filename = hob["filename"][()].decode("utf-8")
            msh.transform = vedo.LinearTransform(dataset["transform"][()])

            msh.properties.SetRepresentation(props["representation"][()])
            msh.properties.SetPointSize(props["pointsize"][()])

            msh.properties.SetEdgeVisibility(props["linewidth"][()]>0)
            if props["linewidth"][()]:
                msh.linewidth(props["linewidth"][()])
                msh.properties.SetEdgeColor(props["linecolor"][()])

            msh.properties.SetAmbient(props["ambient"][()])
            msh.properties.SetDiffuse(props["diffuse"][()])
            msh.properties.SetSpecular(props["specular"][()])
            msh.properties.SetSpecularPower(props["specularpower"][()])
            msh.properties.SetSpecularColor(props["specularcolor"][()])
            msh.properties.SetInterpolation(props["shading"][()])  # flat, phong
            msh.properties.SetColor(props["color"][()])
            msh.properties.SetOpacity(props["alpha"][()])
            msh.properties.SetLighting(props["lighting_is_on"][()])
            if props["backcolor"][()]:
                bfp = msh.actor.GetBackfaceProperty()
                bfp.SetColor(props["backcolor"][()])
            msh.mapper.SetScalarVisibility(props["scalar_visibility"][()])

            plt.add(msh)

    cam = scene["camera"]
    if cam:
        if "pos" in cam.keys():
            plt.camera.SetPosition(cam["pos"][()])
        if "focal_point" in cam.keys():
            plt.camera.SetFocalPoint(cam["focal_point"][()])
        if "viewup" in cam.keys():
            plt.camera.SetViewUp(cam["viewup"][()])
        if "distance" in cam.keys():
            plt.camera.SetDistance(cam["distance"][()])
        if "clipping_range" in cam.keys():
            plt.camera.SetClippingRange(cam["clipping_range"][()])
        plt.resetcam = False

    hfile.close()
    return plt


###########################################################
def loadImageData(filename):
    """Read and return a `vtkImageData` object from file."""
    if ".tif" in filename.lower():
        reader = vtk.new("TIFFReader")
        # print("GetOrientationType ", reader.GetOrientationType())
        reader.SetOrientationType(settings.tiff_orientation_type)
    elif ".slc" in filename.lower():
        reader = vtk.new("SLCReader")
        if not reader.CanReadFile(filename):
            vedo.logger.error(f"sorry, bad SLC file {filename}")
            return None
    elif ".vti" in filename.lower():
        reader = vtk.new("XMLImageDataReader")
    elif ".mhd" in filename.lower():
        reader = vtk.new("MetaImageReader")
    elif ".dem" in filename.lower():
        reader = vtk.new("DEMReader")
    elif ".nii" in filename.lower():
        reader = vtk.new("NIFTIImageReader")
    elif ".nrrd" in filename.lower():
        reader = vtk.new("NrrdReader")
        if not reader.CanReadFile(filename):
            vedo.logger.error(f"sorry, bad NRRD file {filename}")
            return None
    else:
        vedo.logger.error(f"sorry, cannot read file {filename}")
        return None
    reader.SetFileName(filename)
    reader.Update()
    image = reader.GetOutput()
    return image

###########################################################
def write(objct, fileoutput, binary=True):
    """
    Write object to file. Same as `save()`.

    Supported extensions are:
    
    - `vtk, vti, ply, obj, stl, byu, vtp, vti, mhd, xyz, xml, tif, png, bmp`
    """
    obj = objct.dataset

    fr = fileoutput.lower()
    if fr.endswith(".vtk"):
        writer = vtk.new("DataSetWriter")
    elif fr.endswith(".ply"):
        writer = vtk.new("PLYWriter")
        writer.AddComment("PLY file generated by vedo")
        lut = objct.mapper.GetLookupTable()
        if lut:
            pscal = obj.GetPointData().GetScalars()
            if not pscal:
                pscal = obj.GetCellData().GetScalars()
            if pscal and pscal.GetName():
                writer.SetArrayName(pscal.GetName())
            writer.SetLookupTable(lut)
    elif fr.endswith(".stl"):
        writer = vtk.new("STLWriter")
    elif fr.endswith(".vtp"):
        writer = vtk.new("XMLPolyDataWriter")
    elif fr.endswith(".vtu"):
        writer = vtk.new("XMLUnstructuredGridWriter")
    elif fr.endswith(".xyz"):
        writer = vtk.new("SimplePointsWriter")
    elif fr.endswith(".facet"):
        writer = vtk.new("FacetWriter")
    elif fr.endswith(".vti"):
        writer = vtk.new("XMLImageDataWriter")
    elif fr.endswith(".mhd"):
        writer = vtk.new("MetaImageWriter")
    elif fr.endswith(".nii"):
        writer = vtk.new("NIFTIImageWriter")
    elif fr.endswith(".png"):
        writer = vtk.new("PNGWriter")
    elif fr.endswith(".jpg"):
        writer = vtk.new("JPEGWriter")
    elif fr.endswith(".bmp"):
        writer = vtk.new("BMPWriter")
    elif fr.endswith(".tif") or fr.endswith(".tiff"):
        writer = vtk.new("TIFFWriter")
        writer.SetFileDimensionality(len(obj.GetDimensions()))
    elif fr.endswith(".obj"):
        with open(fileoutput, "w", encoding="UTF-8") as outF:
            outF.write("# OBJ file format with ext .obj\n")
            outF.write("# File generated by vedo\n")

            for p in objct.vertices:
                outF.write("v {:.5g} {:.5g} {:.5g}\n".format(*p))

            ptxt = objct.dataset.GetPointData().GetTCoords()
            if ptxt:
                ntxt = utils.vtk2numpy(ptxt)
                for vt in ntxt:
                    outF.write("vt " + str(vt[0]) + " " + str(vt[1]) + " 0.0\n")

            if isinstance(objct, Mesh):
                for i, f in enumerate(objct.cells):
                    fs = ""
                    for fi in f:
                        if ptxt:
                            fs += f" {fi+1}/{fi+1}"
                        else:
                            fs += f" {fi+1}"
                    outF.write(f"f{fs}\n")

                for l in objct.lines:
                    ls = ""
                    for li in l:
                        ls += str(li + 1) + " "
                    outF.write(f"l {ls}\n")
        return objct

    elif fr.endswith(".xml"):  # write tetrahedral dolfin xml
        vertices = objct.vertices.astype(str)
        faces = np.array(objct.cells).astype(str)
        ncoords = vertices.shape[0]
        with open(fileoutput, "w", encoding="UTF-8") as outF:
            outF.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            outF.write('<dolfin xmlns:dolfin="http://www.fenicsproject.org">\n')

            if len(faces[0]) == 4:  # write tetrahedral mesh
                ntets = faces.shape[0]
                outF.write('  <mesh celltype="tetrahedron" dim="3">\n')
                outF.write('    <vertices size="' + str(ncoords) + '">\n')
                for i in range(ncoords):
                    x, y, z = vertices[i]
                    outF.write('      <vertex index="'+str(i)+'" x="'+x+'" y="'+y+'" z="'+z+'"/>\n')
                outF.write('    </vertices>\n')
                outF.write('    <cells size="' + str(ntets) + '">\n')
                for i in range(ntets):
                    v0, v1, v2, v3 = faces[i]
                    outF.write('     <tetrahedron index="'+str(i)
                               + '" v0="'+v0+'" v1="'+v1+'" v2="'+v2+'" v3="'+v3+'"/>\n')

            elif len(faces[0]) == 3:  # write triangle mesh
                ntri = faces.shape[0]
                outF.write('  <mesh celltype="triangle" dim="2">\n')
                outF.write('    <vertices size="' + str(ncoords) + '">\n')
                for i in range(ncoords):
                    x, y, dummy_z = vertices[i]
                    outF.write('      <vertex index="'+str(i)+'" x="'+x+'" y="'+y+'"/>\n')
                outF.write('    </vertices>\n')
                outF.write('    <cells size="' + str(ntri) + '">\n')
                for i in range(ntri):
                    v0, v1, v2 = faces[i]
                    outF.write('     <triangle index="'+str(i)+'" v0="'+v0+'" v1="'+v1+'" v2="'+v2+'"/>\n')

            outF.write("    </cells>\n")
            outF.write("  </mesh>\n")
            outF.write("</dolfin>\n")
        return objct

    else:
        vedo.logger.error(f"Unknown format {fileoutput}, file not saved")
        return objct

    try:
        if binary:
            writer.SetFileTypeToBinary()
        else:
            writer.SetFileTypeToASCII()
    except AttributeError:
        pass

    try:
        writer.SetInputData(obj)
        writer.SetFileName(fileoutput)
        writer.Write()
    except:
        vedo.logger.error(f"could not save {fileoutput}")
    return objct

def save(obj, fileoutput="out.png", binary=True):
    """Save an object to file. Same as `write()`."""
    return write(obj, fileoutput, binary)

###############################################################################
def export_window(fileoutput, binary=False, plt=None):
    """
    Exporter which writes out the rendered scene into an HTML, X3D
    HDF5 or Numpy file.

    Example:
        - [export_x3d.py](https://github.com/marcomusy/vedo/tree/master/examples/other/export_x3d.py)

        Check out the HTML generated webpage [here](https://vedo.embl.es/examples/embryo.html).

        <img src='https://user-images.githubusercontent.com/32848391/57160341-c6ffbd80-6de8-11e9-95ff-7215ce642bc5.jpg' width="600"/>

    .. note::
        the rendering window can also be exported to `numpy` file `scene.npz`
        by pressing `E` key at any moment during visualization.
    """
    if plt is None:
        plt = vedo.plotter_instance

    fr = fileoutput.lower()
    ####################################################################
    if fr.endswith(".npy") or fr.endswith(".npz"):
        _export_npy(plt, fileoutput)

    ####################################################################
    elif fr.endswith(".v3d") or fr.endswith(".h5") or fr.endswith(".hdf5"):
        _export_hdf5(plt, fileoutput)

    ####################################################################
    elif fr.endswith(".x3d"):
        # obj = plt.get_actors()
        # if plt.axes_instances:
        #     obj.append(plt.axes_instances[0])

        # for a in obj:
        #     if isinstance(a, Assembly):
        #         plt.remove(a)
        #         plt.add(a.unpack())

        plt.render()

        exporter = vtk.new("X3DExporter")
        exporter.SetBinary(binary)
        exporter.FastestOff()
        exporter.SetInput(plt.window)
        exporter.SetFileName(fileoutput)
        # exporter.WriteToOutputStringOn()
        exporter.Update()
        exporter.Write()

        wsize = plt.window.GetSize()
        x3d_html = _x3d_html_template.replace("~fileoutput", fileoutput)
        x3d_html = x3d_html.replace("~width",  str(wsize[0]))
        x3d_html = x3d_html.replace("~height", str(wsize[1]))
        with open(fileoutput.replace(".x3d", ".html"), "w", encoding="UTF-8") as outF:
            outF.write(x3d_html)

    ####################################################################
    elif fr.endswith(".html"):
        savebk = vedo.notebook_backend
        vedo.notebook_backend = "k3d"
        vedo.settings.default_backend = "k3d"
        # acts = plt.get_actors()
        plt = vedo.backends.get_notebook_backend(plt.objects)

        with open(fileoutput, "w", encoding="UTF-8") as fp:
            fp.write(plt.get_snapshot())

        vedo.notebook_backend = savebk
        vedo.settings.default_backend = savebk

    else:
        vedo.logger.error(f"export extension {fr.split('.')[-1]} is not supported")

    return plt

#########################################################################
def _export_npy(plt, fileoutput="scene.npz"):

    def _tonumpy(act):
        """Dump a vedo object to numpy format."""

        adict = {}
        adict["type"] = "unknown"

        ########################################################
        def _fillcommon(obj, adict):
            adict["filename"] = obj.filename
            adict["name"] = obj.name
            adict["time"] = obj.time
            adict["rendered_at"] = obj.rendered_at
            adict["position"] = obj.pos()
            adict["info"] = obj.info

            try:
                # GetMatrix might not exist for non linear transforms
                m = np.eye(4)
                vm = obj.get_transform().GetMatrix()
                for i in [0, 1, 2, 3]:
                    for j in [0, 1, 2, 3]:
                        m[i, j] = vm.GetElement(i, j)
                adict["transform"] = m
                minv = np.eye(4)
                vm.Invert()
                for i in [0, 1, 2, 3]:
                    for j in [0, 1, 2, 3]:
                        minv[i, j] = vm.GetElement(i, j)
                adict["transform_inverse"] = minv
            except AttributeError:
                adict["transform"] = []
                adict["transform_inverse"] = []

        ########################################################
        def _fillmesh(obj, adict):
            poly = obj.dataset
            adict["points"] = obj.vertices.astype(float)

            adict["cells"] = None
            if poly.GetNumberOfPolys():
                adict["cells"] = obj.cells_as_flat_array

            adict["lines"] = None
            if poly.GetNumberOfLines():
                adict["lines"] = obj.lines#_as_flat_array
            # print("adict[lines]", adict["lines"])

            adict["pointdata"] = {}
            for iname in obj.pointdata.keys():
                if "normals" in iname.lower():
                    continue
                adict["pointdata"][iname] = obj.pointdata[iname]

            adict["celldata"] = {}
            for iname in obj.celldata.keys():
                if "normals" in iname.lower():
                    continue
                adict["celldata"][iname] = obj.celldata[iname]

            adict["activedata"] = None
            if poly.GetPointData().GetScalars():
                adict["activedata"] = ["pointdata", poly.GetPointData().GetScalars().GetName()]
            elif poly.GetCellData().GetScalars():
                adict["activedata"] = ["celldata", poly.GetCellData().GetScalars().GetName()]

            adict["LUT"] = None
            adict["LUT_range"] = None
            lut = obj.mapper.GetLookupTable()
            if lut:
                nlut = lut.GetNumberOfTableValues()
                lutvals = []
                for i in range(nlut):
                    v4 = lut.GetTableValue(i)  # r, g, b, alpha
                    lutvals.append(v4)
                adict["LUT"] = np.array(lutvals, dtype=np.float32)
                adict["LUT_range"] = np.array(lut.GetRange())

            prp = obj.properties
            adict["alpha"] = prp.GetOpacity()
            adict["representation"] = prp.GetRepresentation()
            adict["pointsize"] = prp.GetPointSize()

            adict["linecolor"] = None
            adict["linewidth"] = None
            if prp.GetEdgeVisibility():
                adict["linewidth"] = obj.linewidth()
                adict["linecolor"] = prp.GetEdgeColor()

            adict["ambient"] = prp.GetAmbient()
            adict["diffuse"] = prp.GetDiffuse()
            adict["specular"] = prp.GetSpecular()
            adict["specularpower"] = prp.GetSpecularPower()
            adict["specularcolor"] = prp.GetSpecularColor()
            adict["shading"] = prp.GetInterpolation()  # flat phong..:
            adict["color"] = prp.GetColor()
            adict["lighting_is_on"] = prp.GetLighting()
            adict["backcolor"] = None
            if obj.actor.GetBackfaceProperty():
                adict["backcolor"] = obj.actor.GetBackfaceProperty().GetColor()

            adict["scalarvisibility"] = obj.mapper.GetScalarVisibility()

        #####################################################################
        obj = act.retrieve_object()

        ######################################################## Assembly
        if isinstance(obj, Assembly):
            pass

        ######################################################## Points/Mesh
        elif isinstance(obj, Points):
            adict["type"] = "Mesh"
            _fillcommon(obj, adict)
            _fillmesh(obj, adict)

        ######################################################## Volume
        elif isinstance(obj, Volume):
            adict["type"] = "Volume"
            _fillcommon(obj, adict)
            imgdata = obj.dataset
            arr = utils.vtk2numpy(imgdata.GetPointData().GetScalars())
            adict["array"] = arr.reshape(imgdata.GetDimensions())
            adict["mode"] = obj.mode()

            prp = obj.properties
            ctf = prp.GetRGBTransferFunction()
            otf = prp.GetScalarOpacity()
            gotf = prp.GetGradientOpacity()
            smin, smax = ctf.GetRange()
            xs = np.linspace(smin, smax, num=100, endpoint=True)
            cols, als, algrs = [], [], []
            for x in xs:
                cols.append(ctf.GetColor(x))
                als.append(otf.GetValue(x))
                if gotf:
                    algrs.append(gotf.GetValue(x))
            adict["color"] = cols
            adict["alpha"] = als
            adict["alphagrad"] = algrs

        ######################################################## Image
        elif isinstance(obj, Image):
            adict["type"] = "Image"
            _fillcommon(obj, adict)
            adict["array"] = obj.tonumpy()

        ######################################################## Text2D
        elif isinstance(obj, vedo.Text2D):
            adict["type"] = "Text2D"
            adict["rendered_at"] = obj.rendered_at
            adict["text"] = obj.text()
            adict["position"] = obj.GetPosition()
            adict["color"] = obj.properties.GetColor()
            adict["font"] = obj.fontname
            adict["size"] = obj.properties.GetFontSize() / 22.5
            adict["bgcol"] = obj.properties.GetBackgroundColor()
            adict["alpha"] = obj.properties.GetBackgroundOpacity()
            adict["frame"] = obj.properties.GetFrame()

        else:
            pass
        return adict

    sdict = {}
    sdict["shape"] = plt.shape
    sdict["sharecam"] = plt.sharecam
    sdict["camera"] = dict(
        pos=plt.camera.GetPosition(),
        focal_point=plt.camera.GetFocalPoint(),
        viewup=plt.camera.GetViewUp(),
        distance=plt.camera.GetDistance(),
        clipping_range=plt.camera.GetClippingRange(),
        parallel_scale=plt.camera.GetParallelScale(),
    )
    sdict["position"] = plt.pos
    sdict["size"] = plt.size
    sdict["axes"] = plt.axes
    sdict["title"] = plt.title
    sdict["backgrcol"] = colors.get_color(plt.renderer.GetBackground())
    sdict["backgrcol2"] = None
    if plt.renderer.GetGradientBackground():
        sdict["backgrcol2"] = plt.renderer.GetBackground2()
    sdict["use_depth_peeling"] = plt.renderer.GetUseDepthPeeling()
    sdict["render_lines_as_tubes"] = settings.render_lines_as_tubes
    sdict["hidden_line_removal"] = settings.hidden_line_removal
    sdict["use_parallel_projection"] = plt.camera.GetParallelProjection()
    sdict["default_font"] = settings.default_font

    sdict["objects"] = []

    allobjs = plt.get_actors()
    acts2d = plt.renderer.GetActors2D()
    acts2d.InitTraversal()
    for _ in range(acts2d.GetNumberOfItems()):
        a = acts2d.GetNextItem()
        # if isinstance(a, vedo.Text2D):
        allobjs.append(a)

    for a in allobjs:
        try:
            if a.actor.GetVisibility():
                sdict["objects"].append(_tonumpy(a))
        except AttributeError:
            try:
                if a.GetVisibility():
                    sdict["objects"].append(_tonumpy(a))
            except AttributeError:
                pass

    if fileoutput.endswith(".npz"):
        np.savez_compressed(fileoutput, vedo_scenes=[sdict])
    else:
        np.save(fileoutput, [sdict])

#########################################################################
def _export_hdf5(plt, fileoutput="scene.h5"):
    try:
        import h5py
    except ImportError as e:
        vedo.logger.error(f"{e}. Try: 'pip install h5py'")
        return
    
    hfile = h5py.File(fileoutput, "w")

    scene = hfile.create_group("scene")

    scene["shape"] = plt.shape
    scene["sharecam"] = plt.sharecam

    camera = scene.create_group("camera")
    cdict = dict(
        pos=plt.camera.GetPosition(),
        focal_point=plt.camera.GetFocalPoint(),
        viewup=plt.camera.GetViewUp(),
        distance=plt.camera.GetDistance(),
        clipping_range=plt.camera.GetClippingRange(),
    )
    camera.attrs.update(cdict)

    scene["position"] = plt.pos
    scene["size"] = plt.size
    scene["axes"] = plt.axes if plt.axes else ""
    scene["title"] = str(plt.title)
    scene["background_color"] = colors.get_color(plt.renderer.GetBackground())
    if plt.renderer.GetGradientBackground():
        scene["background_color2"] = plt.renderer.GetBackground2()
    else:
        scene["background_color2"] = ""
    scene["use_depth_peeling"] = settings.use_depth_peeling
    scene["render_lines_as_tubes"] = settings.render_lines_as_tubes
    scene["hidden_line_removal"] = settings.hidden_line_removal
    scene["use_parallel_projection"] = plt.camera.GetParallelProjection()
    scene["default_font"] = settings.default_font

    onscreen = []
    for a in plt.get_actors():
        onscreen.append(a.retrieve_object())

    vobjs = []
    for i, vob in enumerate(set(plt.objects + onscreen)):
        if isinstance(vob, str):
            vobjs.append(vedo.Text2D(vob))
        elif not vob.actor.GetVisibility():
            continue
        elif not hasattr(vob, "name"):
            continue
        elif isinstance(vob, Assembly):
            vobjs += vob.recursive_unpack()
        else:
            vobjs.append(vob)

    objects = scene.create_group("objects")
    for i, vob in enumerate(set(vobjs)):

        cname = vob.__class__.__name__
        hmesh = objects.create_group(f"{cname}_{vob.name}_{i}")
        hmesh["type"] = "Mesh" if vob.ncells else "Points"

        hmesh["filename"] = vob.filename
        hmesh["name"] = vob.name
        hmesh["time"] = vob.time
        hmesh["rendered_at"] = list(vob.rendered_at)

        info = hmesh.create_group("info")
        info.attrs.update(vob.info)

        props = hmesh.create_group("properties")

        dataset = hmesh.create_group("dataset")

        copt = dict(compression="gzip", compression_opts=9)
        dataset.create_dataset("points", data=vob.vertices, dtype=np.float32, **copt)

        cells = np.array([])
        try:
            cells = vob.cells_as_flat_array
            if vob.nvertices <     256: #careful, vertices not cells!
                dataset.create_dataset("cells", data=cells, dtype=np.uint8, **copt)
            elif vob.nvertices < 65535: #careful, vertices not cells!
                dataset.create_dataset("cells", data=cells, dtype=np.uint16, **copt)
            else:
                dataset.create_dataset("cells", data=cells, dtype=np.uint32, **copt)
        except AttributeError as e:
            print("cells fails for", e)
            pass
            dataset.create_dataset("cells", data=cells, dtype=np.uint32, **copt)

        lns = np.array([])
        try:
            if vob.dataset.GetNumberOfLines():
                lns = vob.lines_as_flat_array
        except AttributeError as e:
            print("lines fails for", e)
            pass
        dataset.create_dataset("lines", data=lns, dtype=np.uint32, **copt)

        ######################################################## Points-Mesh
        try:
            dataset.create_dataset("transform",  data=vob.transform.matrix)
        except AttributeError:
            dataset.create_dataset("transform",  data=np.eye(4))

        try:
            dataset.create_group("pointdata")
            for key in vob.pointdata.keys():
                if "Normals" in key:
                    continue
                dataset["pointdata"].create_dataset(key, data=vob.pointdata[key])
            dataset.create_group("celldata")
            for key in vob.celldata.keys():
                if "Normals" in key:
                    continue
                dataset["celldata"].create_dataset(key, data=vob.celldata[key])        
            dataset.create_group("metadata")
            for key in vob.metadata.keys():
                dataset["metadata"].create_dataset(key, data=vob.metadata[key])

            v = vob.dataset.GetPointData().GetScalars()
            dataset["pointdata"]["active_scalars"] = v.GetName() if v else ""
            v = vob.dataset.GetPointData().GetVectors()
            dataset["pointdata"]["active_vectors"] = v.GetName() if v else ""
            v = vob.dataset.GetPointData().GetTensors()
            dataset["pointdata"]["active_tensors"] = v.GetName() if v else ""

            v = vob.dataset.GetCellData().GetScalars()
            dataset["celldata"]["active_scalars"] = v.GetName() if v else ""
            v = vob.dataset.GetCellData().GetVectors()
            dataset["celldata"]["active_vectors"] = v.GetName() if v else ""
            v = vob.dataset.GetCellData().GetTensors()
            dataset["celldata"]["active_tensors"] = v.GetName() if v else ""

        except AttributeError as e:
            # print("pointcelldata fails for", e)
            pass

        try:
            lut = vob.mapper.GetLookupTable()
            if lut:
                nlut = lut.GetNumberOfTableValues()
                lutvals = []
                for i in range(nlut):
                    v4 = lut.GetTableValue(i)  # r, g, b, alpha
                    lutvals.append(v4)
                props["lut"] = lutvals
                props["lut_range"] = lut.GetRange()
            else:
                props["lut"] = None
                props["lut_range"] = None

            props["representation"] = vob.properties.GetRepresentation()
            props["pointsize"] = vob.properties.GetPointSize()

            evis = vob.properties.GetEdgeVisibility()
            props["linewidth"] = vob.linewidth() if evis else 0
            props["linecolor"] = vob.properties.GetEdgeColor() if evis else ""

            props["ambient"] = vob.properties.GetAmbient()
            props["diffuse"] = vob.properties.GetDiffuse()
            props["specular"] = vob.properties.GetSpecular()
            props["specularpower"] = vob.properties.GetSpecularPower()
            props["specularcolor"] = vob.properties.GetSpecularColor()
            props["shading"] = vob.properties.GetInterpolation()  # flat, phong
            props["color"] = vob.properties.GetColor()
            props["alpha"] = vob.properties.GetOpacity()
            props["lighting_is_on"] = vob.properties.GetLighting()
            bfp = vob.actor.GetBackfaceProperty()
            props["backcolor"] = bfp.GetColor() if bfp else ""
            props["scalar_visibility"] = vob.mapper.GetScalarVisibility()

        except AttributeError:
            pass

        ######################################################## Volume
        if isinstance(vob, vedo.Volume):
            try:
                # arr = utils.vtk2numpy(vob.dataset.GetPointData().GetScalars())
                # arr = arr.reshape(vob.dataset.GetDimensions())
                # dataset.create_dataset("array", data=arr)
                ctf = vob.properties.GetRGBTransferFunction()
                otf = vob.properties.GetScalarOpacity()
                gotf = vob.properties.GetGradientOpacity()
                smin, smax = ctf.GetRange()
                xs = np.linspace(smin, smax, num=100, endpoint=True)
                cols, als, algrs = [], [], []
                for x in xs:
                    cols.append(ctf.GetColor(x))
                    als.append(otf.GetValue(x))
                    if gotf:
                        algrs.append(gotf.GetValue(x))
                props["color"] = cols
                props["alpha"] = als
                props["alphagrad"] = algrs
                props["mode"] = vob.mode()
            except AttributeError as e:
                # print("vol fails for", e)
                pass

        ######################################################## Image
        if isinstance(vob, vedo.Image):
            try:
                dataset["array"] = vob.tonumpy()
            except AttributeError as e:
                # print("img fails for", e)
                pass

        ######################################################## Text2D
        if isinstance(vob, vedo.Text2D):
            props["text"] = vob.text()
            props["position"] = vob.GetPosition()
            props["color"] = vob.properties.GetColor()
            props["font"] = vob.fontname
            props["size"] = vob.properties.GetFontSize() / 22.5
            props["bgcol"] = vob.properties.GetBackgroundColor()
            props["alpha"] = vob.properties.GetBackgroundOpacity()
            props["frame"] = vob.properties.GetFrame()

    hfile.close()


def import_window(fileinput, mtl_file=None, texture_path=None):
    """Import a whole scene from a Numpy, HDF5 or OBJ wavefront file.

    Arguments:
        mtl_file : (str)
            MTL file for OBJ wavefront files
        texture_path : (str)
            path of the texture files directory

    Returns:
        `Plotter` instance
    """
    if fileinput.endswith(".npy") or fileinput.endswith(".npz"):
        return _import_npy(fileinput)
    
    elif fileinput.endswith(".h5") or fileinput.endswith(".hdf5"):
        return _import_hdf5(fileinput)

    elif ".obj" in fileinput.lower():

        window = vtk.vtkRenderWindow()
        window.SetOffScreenRendering(1)
        renderer = vtk.vtkRenderer()
        window.AddRenderer(renderer)

        importer = vtk.new("OBJImporter")
        importer.SetFileName(fileinput)
        if mtl_file is not False:
            if mtl_file is None:
                mtl_file = fileinput.replace(".obj", ".mtl").replace(".OBJ", ".MTL")
            importer.SetFileNameMTL(mtl_file)
        if texture_path is not False:
            if texture_path is None:
                texture_path = fileinput.replace(".obj", ".txt").replace(".OBJ", ".TXT")
            importer.SetTexturePath(texture_path)
        importer.SetRenderWindow(window)
        importer.Update()

        plt = vedo.Plotter()
        actors = renderer.GetActors()
        actors.InitTraversal()
        for _ in range(actors.GetNumberOfItems()):
            vactor = actors.GetNextActor()
            act = Mesh(vactor)
            act_tu = vactor.GetTexture()
            if act_tu:
                act.texture(act_tu)
            plt.actors.append(act)
        return plt

    return None


##########################################################
def screenshot(filename="screenshot.png", scale=1, asarray=False):
    """
    Save a screenshot of the current rendering window.

    Arguments:
        scale : (int)
            Set image magnification as an integer multiplicative factor.
            E.g. setting a magnification of 2 produces an image twice as large,
            but 10x slower to generate.
        asarray : (bool)
            Return a numpy array of the image
    """
    if not vedo.plotter_instance or not vedo.plotter_instance.window:
        # vedo.logger.error("in screenshot(), rendering window is not present, skip.")
        return vedo.plotter_instance  ##########

    if asarray and scale == 1 and not vedo.plotter_instance.offscreen:
        nx, ny = vedo.plotter_instance.window.GetSize()
        arr = vtk.vtkUnsignedCharArray()
        vedo.plotter_instance.window.GetRGBACharPixelData(0, 0, nx-1, ny-1, 0, arr)
        narr = vedo.vtk2numpy(arr).T[:3].T.reshape([ny, nx, 3])
        narr = np.flip(narr, axis=0)
        return narr  ##########

    filename = str(filename)

    if filename.endswith(".pdf"):
        writer = vtk.new("GL2PSExporter")
        writer.SetRenderWindow(vedo.plotter_instance.window)
        writer.Write3DPropsAsRasterImageOff()
        writer.SilentOn()
        writer.SetSortToBSP()
        writer.SetFileFormatToPDF()
        writer.SetFilePrefix(filename.replace(".pdf", ""))
        writer.Write()
        return vedo.plotter_instance  ##########

    elif filename.endswith(".svg"):
        writer = vtk.new("GL2PSExporter")
        writer.SetRenderWindow(vedo.plotter_instance.window)
        writer.Write3DPropsAsRasterImageOff()
        writer.SilentOn()
        writer.SetSortToBSP()
        writer.SetFileFormatToSVG()
        writer.SetFilePrefix(filename.replace(".svg", ""))
        writer.Write()
        return vedo.plotter_instance  ##########

    elif filename.endswith(".eps"):
        writer = vtk.new("GL2PSExporter")
        writer.SetRenderWindow(vedo.plotter_instance.window)
        writer.Write3DPropsAsRasterImageOff()
        writer.SilentOn()
        writer.SetSortToBSP()
        writer.SetFileFormatToEPS()
        writer.SetFilePrefix(filename.replace(".eps", ""))
        writer.Write()
        return vedo.plotter_instance  ##########

    if settings.screeshot_large_image:
        w2if = vtk.new("RenderLargeImage")
        w2if.SetInput(vedo.plotter_instance.renderer)
        w2if.SetMagnification(scale)
    else:
        w2if = vtk.new("WindowToImageFilter")
        w2if.SetInput(vedo.plotter_instance.window)
        if hasattr(w2if, "SetScale"):
            w2if.SetScale(int(scale), int(scale))
        if settings.screenshot_transparent_background:
            w2if.SetInputBufferTypeToRGBA()
        w2if.ReadFrontBufferOff()  # read from the back buffer
    w2if.Update()

    if asarray:
        pd = w2if.GetOutput().GetPointData()
        npdata = utils.vtk2numpy(pd.GetArray("ImageScalars"))
        npdata = npdata[:, [0, 1, 2]]
        ydim, xdim, _ = w2if.GetOutput().GetDimensions()
        npdata = npdata.reshape([xdim, ydim, -1])
        npdata = np.flip(npdata, axis=0)
        return npdata ###########################

    if filename.lower().endswith(".png"):
        writer = vtk.new("PNGWriter")
        writer.SetFileName(filename)
        writer.SetInputData(w2if.GetOutput())
        writer.Write()
    elif filename.lower().endswith(".jpg") or filename.lower().endswith(".jpeg"):
        writer = vtk.new("JPEGWriter")
        writer.SetFileName(filename)
        writer.SetInputData(w2if.GetOutput())
        writer.Write()
    else:  # add .png
        writer = vtk.new("PNGWriter")
        writer.SetFileName(filename + ".png")
        writer.SetInputData(w2if.GetOutput())
        writer.Write()
    return vedo.plotter_instance


def ask(*question, **kwarg):
    """
    Ask a question from command line. Return the answer as a string.
    See function `colors.printc()` for the description of the keyword options.

    Arguments:
        options : (list)
            a python list of possible answers to choose from.
        default : (str)
            the default answer when just hitting return.

    Example:
        ```python
        import vedo
        res = vedo.file_io.ask("Continue?", options=['Y','n'], default='Y', c='g')
        print(res)
        ```
    """
    kwarg.update({"end": " "})
    if "invert" not in kwarg:
        kwarg.update({"invert": True})
    if "box" in kwarg:
        kwarg.update({"box": ""})

    options = kwarg.pop("options", [])
    default = kwarg.pop("default", "")
    if options:
        opt = "["
        for o in options:
            opt += o + "/"
        opt = opt[:-1] + "]"
        colors.printc(*question, opt, **kwarg)
    else:
        colors.printc(*question, **kwarg)

    resp = input()

    if options:
        if resp not in options:
            if default and str(repr(resp)) == "''":
                return default
            colors.printc("Please choose one option in:", opt, italic=True, bold=False)
            kwarg["options"] = options
            return ask(*question, **kwarg)  # ask again
    return resp


##############################################################################################
class Video:
    """
    Generate a video from a rendering window.
    """

    def __init__(self, name="movie.mp4", duration=None, fps=24, backend="imageio"):
        """
        Class to generate a video from the specified rendering window.
        Program `ffmpeg` is used to create video from each generated frame.

        Arguments:
            name : (str)
                name of the output file.
            fps : (int)
                set the number of frames per second.
            duration : (float)
                set the total `duration` of the video and recalculates `fps` accordingly.
            backend : (str)
                the backend engine to be used `['imageio', 'ffmpeg', 'cv']`

        Examples:
            - [make_video.py](https://github.com/marcomusy/vedo/tree/master/examples/other/make_video.py)

            ![](https://user-images.githubusercontent.com/32848391/50739007-2bfc2b80-11da-11e9-97e6-620a3541a6fa.jpg)
        """
        self.name = name
        self.duration = duration
        self.backend = backend
        self.fps = float(fps)
        self.command = "ffmpeg -loglevel panic -y -r"
        self.options = "-b:v 8000k"

        self.frames = []
        self.tmp_dir = TemporaryDirectory()
        self.get_filename = lambda x: os.path.join(self.tmp_dir.name, x)
        colors.printc(":video:  Video file", self.name, "is open... ", c="m", end="")

    def add_frame(self):
        """Add frame to current video."""
        fr = self.get_filename(str(len(self.frames)) + ".png")
        screenshot(fr)
        self.frames.append(fr)
        return self

    def pause(self, pause=0):
        """Insert a `pause`, in seconds."""
        fr = self.frames[-1]
        n = int(self.fps * pause)
        for _ in range(n):
            fr2 = self.get_filename(str(len(self.frames)) + ".png")
            self.frames.append(fr2)
            os.system("cp -f %s %s" % (fr, fr2))
        return self

    def action(self, elevation=(0, 80), azimuth=(0, 359), cameras=(), resetcam=False):
        """
        Automatic shooting of a static scene by specifying rotation and elevation ranges.

        Arguments:
            elevation : list
                initial and final elevation angles
            azimuth_range : list
                initial and final azimuth angles
            cameras : list
                list of cameras to go through, each camera can be dictionary or a vtkCamera
        """
        if not self.duration:
            self.duration = 5

        plt = vedo.plotter_instance
        n = int(self.fps * self.duration)

        cams = []
        for cm in cameras:
            cams.append(utils.camera_from_dict(cm))
        nc = len(cams)

        plt.show(resetcam=resetcam, interactive=False)

        if nc:
            for i in range(n):
                plt.move_camera(cams, i / n)
                plt.show()
                self.add_frame()

        else:  ########################################

            for i in range(n):
                plt.camera.Elevation((elevation[1] - elevation[0]) / n)
                plt.camera.Azimuth((azimuth[1] - azimuth[0]) / n)
                plt.show()
                self.add_frame()

        return self

    def close(self):
        """
        Render the video and write it to file.
        """
        if self.duration:
            self.fps = int(len(self.frames) / float(self.duration) + 0.5)
            colors.printc("recalculated fps:", self.fps, c="m", end="")
        else:
            self.fps = int(self.fps)

        ########################################
        if self.backend == "ffmpeg":
            out = os.system(
                self.command
                + " "
                + str(self.fps)
                + " -i "
                + f"'{self.tmp_dir.name}'"
                + os.sep
                + "%01d.png "
                + self.options
                + " "
                + f"'{self.name}'"
            )
            if out:
                vedo.logger.error(f":noentry: backend {self.backend} returning error: {out}")
            else:
                colors.printc(f":save: saved to {self.name}", c="m")

        ########################################
        elif "cv" in self.backend:
            try:
                import cv2
            except ImportError:
                vedo.logger.error("opencv is not installed")
                return

            cap = cv2.VideoCapture(os.path.join(self.tmp_dir.name, "%1d.png"))
            fourcc = cv2.VideoWriter_fourcc(*"mp4v")
            w, h = vedo.plotter_instance.window.GetSize()
            writer = cv2.VideoWriter(self.name, fourcc, self.fps, (w, h), True)

            while True:
                ret, frame = cap.read()
                if not ret:
                    break
                writer.write(frame)

            cap.release()
            writer.release()

        ########################################
        elif "imageio" in self.backend:
            try:
                import imageio
            except ImportError:
                vedo.logger.error("Please install imageio with:\n pip install imageio[ffmpeg]")
                return

            if self.name.endswith(".mp4"):
                writer = imageio.get_writer(self.name, fps=self.fps)
            elif self.name.endswith(".gif"):
                writer = imageio.get_writer(self.name, mode="I", duration=1 / self.fps)
            elif self.name.endswith(".webm"):
                writer = imageio.get_writer(self.name, format="webm", fps=self.fps)
            else:
                vedo.logger.error(f"Unknown format of {self.name}.")
                return

            for f in utils.humansort(self.frames):
                image = imageio.v3.imread(f)
                writer.append_data(image)
            try:
                writer.close()
                colors.printc(f"... saved as {self.name}", c="m")
            except:
                colors.printc(f":noentry: Could not save video {self.name}", c="r")

        # finalize cleanup
        self.tmp_dir.cleanup()

    def split_frames(self, output_dir="video_frames", prefix="frame_", format="png"):
        """Split an existing video file into frames."""
        try:
            import imageio
        except ImportError:
            vedo.logger.error("\nPlease install imageio with:\n pip install imageio")
            return

        # Create the output directory if it doesn't exist
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

        # Create a reader object to read the video
        reader = imageio.get_reader(self.name)

        # Loop through each frame of the video and save it as image
        print()
        for i, frame in utils.progressbar(
            enumerate(reader), title=f"writing {format} frames", c="m", width=20
        ):
            output_file = os.path.join(output_dir, f"{prefix}{str(i).zfill(5)}.{format}")
            imageio.imwrite(output_file, frame, format=format)
